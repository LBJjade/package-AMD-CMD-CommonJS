<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
  </head>
  <body></body>
  <script type="text/javascript">
    // 第一种方式：字面量
    var o1 = { name: 'o1' };
    var o2 = new Object({ name: 'o2' });
    // 第二种方式：构造函数
    var M = function(name) {
      this.name = name;
    };
    var o3 = new M('o3');
    // 第三种方式：Object.create
    var p = { name: 'p' };
    var o4 = Object.create(p);
    console.log(o1);
    console.log(o2);
    console.log(o3);
    console.log(o4);
    // var M = function (name) { this.name = name; }
    // 用法
    var o3 = new M('o3');
    var o5 = new M();
    o3.__proto__.say = function() {
      console.log('hello world');
    };

    o3.say();
    o5.say();
    var new2 = function(func) {
      var o = Object.create(func.prototype); //创建对象
      var k = func.call(o); //改变this指向，把结果付给k
      if (typeof k === 'object') {
        //判断k的类型是不是对象
        return k; //是，返回k
      } else {
        return o; //不是返回返回构造函数的执行结果
      }
    };

    var a = {};
    console.log(a.prototype); //undefined
    console.log(a.__proto__); //Object {}

    var b = function() {};
    console.log(b.prototype); //b {}
    console.log(b.__proto__); //function() {}

    /*1、字面量方式*/
    var a = {};
    console.log(a.__proto__); //Object {}

    console.log(a.__proto__ === a.constructor.prototype); //true

    /*2、构造器方式*/
    var A = function() {};
    var a = new A();
    console.log(a.__proto__); //A {}

    console.log(a.__proto__ === a.constructor.prototype); //true

    /*3、Object.create()方式*/
    var a1 = { a: 1 };
    var a2 = Object.create(a1);
    console.log(a2.__proto__); //Object {a: 1}

    console.log(a.__proto__ === a.constructor.prototype); //false（此处即为图1中的例外情况）
    var A = function() {};
    var a = new A();
    console.log(a.__proto__); //A {}（即构造器function A 的原型对象）
    console.log(a.__proto__.__proto__); //Object {}（即构造器function Object 的原型对象）
    console.log(a.__proto__.__proto__.__proto__); //null

    Number.__proto__ === Function.prototype; // true
    Number.constructor == Function; //true

    Boolean.__proto__ === Function.prototype; // true
    Boolean.constructor == Function; //true

    String.__proto__ === Function.prototype; // true
    String.constructor == Function; //true

    // 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身
    Object.__proto__ === Function.prototype; // true
    Object.constructor == Function; // true

    // 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身
    Function.__proto__ === Function.prototype; // true
    Function.constructor == Function; //true

    Array.__proto__ === Function.prototype; // true
    Array.constructor == Function; //true

    RegExp.__proto__ === Function.prototype; // true
    RegExp.constructor == Function; //true

    Error.__proto__ === Function.prototype; // true
    Error.constructor == Function; //true

    Date.__proto__ === Function.prototype; // true
    Date.constructor == Function; //true

    var f = new Function('x', 'return x*x;');
    //当然你也可以这么创建 f = function(x){ return x*x }
    console.log(f.arguments); // arguments 方法从哪里来的？
    console.log(f.call(window)); // call 方法从哪里来的？
    console.log(Function.prototype); // function() {} （一个空的函数）
    console.log(Object.getOwnPropertyNames(Function.prototype));

    // instanceof：用于判断引用类型属于哪个构造函数的方法

    //f instanceof Foo的判断逻辑是：

    // f的__proto__一层一层往上，能否对应到Foo.prototype
    // 再试着判断f instance Object
    // 创建 worker
    const worker = new Worker('work.js');

    // 向主进程推送消息
    worker.postMessage('Hello World');

    // 监听主进程来的消息
    worker.onmessage = function(event) {
      console.log('Received message ' + event.data);
    };

    function jsonp(url, jsonpCallback, success) {
      const script = document.createElement('script');
      script.src = url;
      script.async = true;
      script.type = 'text/javascript';
      window[jsonpCallback] = function(data) {
        success && success(data);
      };
      document.body.appendChild(script);
    }

    function add(a, b) {
      return a + b;
    }

    //函数只能传一个参数时候实现加法
    function curry(a) {
      return function(b) {
        return a + b;
      };
    }
    var add2 = curry(2); //add2也就是第一个参数为2的add版本
    console.log(add2(3)); //5

    const curry2 = (fn, ...arg) => {
      let all = arg;
      return (...rest) => {
        all.push(...rest);
        return fn.apply(null, all);
      };
    };
    let add3 = curry2(add, 2);
    console.log(add3(8)); //10
    add3 = curry2(add);
    console.log(add3(2, 8)); //10
  </script>
</html>
